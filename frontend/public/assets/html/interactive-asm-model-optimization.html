<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Chosen Palette: Tech Tonic (Slate & Cyan) -->
    <!-- Application Structure Plan: The application is structured as a single-page, vertical-scrolling narrative. It starts with a high-level introduction, then dives into three core applications (Sensitivity Analysis, Calibration, Optimization) presented in an interactive, tabbed interface. This task-oriented design allows users to explore specific use cases directly. Following the applications, a "How it Works" section breaks down the technical workflow visually. The structure concludes with future prospects. This design was chosen to transform a dense technical report into an engaging learning experience, prioritizing user understanding and exploration over a linear document format. Key interactions include tab switching and button-triggered chart animations to simulate the optimization processes. -->
    <!-- Visualization & Content Choices: 
        1. Sensitivity Analysis: Goal: Compare parameter importance. Method: Horizontal Bar Chart (Chart.js). Interaction: Hover tooltips. Justification: Clearly ranks parameters, making it easy to identify the most influential ones.
        2. Calibration: Goal: Show change/convergence. Method: Line Chart (Chart.js). Interaction: Button-triggered animation showing a prediction line fitting an observation line. Justification: Intuitively visualizes the iterative process of minimizing error.
        3. Process Optimization: Goal: Show relationship/trade-off. Method: 2D Scatter Plot (Chart.js). Interaction: Button-triggered animation moving a point towards an optimal state. Justification: Effectively demonstrates multi-objective optimization (e.g., cost vs. quality).
        4. Workflow Diagram: Goal: Organize/Inform. Method: Styled HTML/CSS Flexbox. Interaction: None, static visual flow. Justification: Provides a clear, step-by-step overview of the underlying technical process without external libraries.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <title>交互式ASM模型优化技术解析</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-800 */
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 350px;
            max-height: 50vh;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .tab-button {
            transition: all 0.3s ease;
        }
        .tab-button.active {
            border-color: #06b6d4; /* cyan-500 */
            color: #06b6d4;
            background-color: #ecfeff; /* cyan-50 */
        }
        .flow-arrow::after {
            content: '→';
            font-size: 2rem;
            color: #94a3b8; /* slate-400 */
            line-height: 1;
        }
    </style>
</head>
<body class="bg-slate-50">

    <main class="container mx-auto px-4 py-8 md:py-12">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-800 mb-4">革新污水处理模型：`torchdiffeq`的力量</h1>
            <p class="text-lg text-slate-600 max-w-3xl mx-auto">一个交互式指南，解析如何利用PyTorch的自动微分与常微分方程求解器，实现活性污泥模型(ASM)的高效分析、校准与优化。</p>
        </header>

        <section id="core-idea" class="mb-16 bg-white p-8 rounded-2xl shadow-lg">
            <h2 class="text-3xl font-bold text-center mb-8 text-slate-800">核心理念：从繁琐到高效的飞跃</h2>
            <div class="grid md:grid-cols-2 gap-8 items-center">
                <div class="border-r-0 md:border-r-2 border-dashed pr-8 border-rose-300">
                    <h3 class="text-2xl font-semibold mb-4 text-rose-600">传统方法</h3>
                    <p class="text-slate-600 mb-4">依赖数值扰动（如有限差分）或复杂的手动推导来进行敏感性分析和校准。这个过程不仅计算成本极高，而且容易出错，难以扩展到大量参数的复杂模型。</p>
                    <div class="space-y-3">
                        <div class="flex items-center p-3 bg-rose-50 rounded-lg">
                            <span class="text-2xl mr-4">⚙️</span>
                            <span>手动推导 / 数值扰动</span>
                        </div>
                        <div class="flex items-center p-3 bg-rose-50 rounded-lg">
                            <span class="text-2xl mr-4">⏳</span>
                            <span>计算成本高昂，效率低下</span>
                        </div>
                        <div class="flex items-center p-3 bg-rose-50 rounded-lg">
                            <span class="text-2xl mr-4">❌</span>
                            <span>容易出错，难以维护</span>
                        </div>
                    </div>
                </div>
                <div class="pl-0 md:pl-8">
                    <h3 class="text-2xl font-semibold mb-4 text-cyan-600">PyTorch 解决方案</h3>
                    <p class="text-slate-600 mb-4">通过 `torch.autograd` 自动计算梯度，并结合 `torchdiffeq` 的高效ODE求解器（特别是伴随状态法），为模型分析与优化提供了自动、精确且高效的全新途径。</p>
                    <div class="space-y-3">
                        <div class="flex items-center p-3 bg-cyan-50 rounded-lg">
                            <span class="text-2xl mr-4">⚡️</span>
                            <span>`autograd` + `torchdiffeq`</span>
                        </div>
                        <div class="flex items-center p-3 bg-cyan-50 rounded-lg">
                            <span class="text-2xl mr-4">🎯</span>
                            <span>自动、精确、高效的梯度</span>
                        </div>
                        <div class="flex items-center p-3 bg-cyan-50 rounded-lg">
                            <span class="text-2xl mr-4">🚀</span>
                            <span>赋能高级分析与优化</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="applications" class="mb-16">
            <h2 class="text-3xl font-bold text-center mb-8 text-slate-800">核心应用探索</h2>
            <div class="w-full max-w-4xl mx-auto">
                <div class="flex justify-center border-b border-slate-200 mb-6">
                    <button class="tab-button active py-3 px-6 text-lg font-medium border-b-2" data-tab="sensitivity">参数敏感性分析</button>
                    <button class="tab-button py-3 px-6 text-lg font-medium border-b-2 border-transparent" data-tab="calibration">模型参数校准</button>
                    <button class="tab-button py-3 px-6 text-lg font-medium border-b-2 border-transparent" data-tab="optimization">高级过程优化</button>
                </div>

                <div id="tab-content" class="bg-white p-6 md:p-8 rounded-2xl shadow-lg">
                    <div id="sensitivity-content" class="tab-pane active">
                        <h3 class="text-2xl font-semibold mb-2 text-slate-700">参数敏感性分析 (PSA)</h3>
                        <p class="text-slate-600 mb-6">此分析旨在识别对模型输出影响最大的关键参数。通过计算输出（如出水COD）对每个参数的梯度，我们可以量化其敏感度。这对于指导参数校准、简化模型和理解模型行为至关重要。</p>
                        <div class="chart-container">
                            <canvas id="sensitivityChart"></canvas>
                        </div>
                    </div>
                    <div id="calibration-content" class="tab-pane hidden">
                        <h3 class="text-2xl font-semibold mb-2 text-slate-700">模型参数校准</h3>
                        <p class="text-slate-600 mb-4">校准是将模型预测与实际观测数据对齐的过程。通过定义一个衡量预测与观测之间差异的“损失函数”，并利用梯度下降等优化算法，我们可以自动调整模型参数，使损失最小化。</p>
                        <div class="chart-container mb-4">
                            <canvas id="calibrationChart"></canvas>
                        </div>
                        <div class="text-center">
                            <button id="calibrateBtn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-6 rounded-lg transition-colors">开始校准</button>
                            <p id="lossDisplay" class="mt-2 text-slate-500">损失 (Loss): 尚未开始</p>
                        </div>
                    </div>
                    <div id="optimization-content" class="tab-pane hidden">
                        <h3 class="text-2xl font-semibold mb-2 text-slate-700">高级过程优化</h3>
                        <p class="text-slate-600 mb-4">超越简单的参数拟合，我们可以优化复杂的运行目标，如在保证出水水质（低EQI）的同时，最小化运行成本（低OCI）。这使得寻找最优的运行策略（如曝气设定点）成为可能。</p>
                         <div class="chart-container mb-4">
                            <canvas id="optimizationChart"></canvas>
                        </div>
                        <div class="text-center">
                            <button id="optimizeBtn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-6 rounded-lg transition-colors">开始优化</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <section id="workflow" class="mb-16 bg-white p-8 rounded-2xl shadow-lg">
            <h2 class="text-3xl font-bold text-center mb-8 text-slate-800">技术工作流程</h2>
            <p class="text-slate-600 mb-10 max-w-3xl mx-auto text-center">无论是进行敏感性分析、参数校准还是过程优化，其核心都遵循一个统一、可微分的计算流程。这个流程将复杂的ODE系统无缝集成到标准的深度学习优化循环中。</p>
            <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4">
                <div class="text-center p-4 bg-slate-100 rounded-lg w-full md:w-auto">
                    <div class="text-2xl mb-2">1️⃣</div>
                    <h4 class="font-semibold">定义ASM为`nn.Module`</h4>
                    <p class="text-sm text-slate-500">将参数封装为`nn.Parameter`</p>
                </div>
                <div class="flow-arrow hidden md:block"></div>
                <div class="text-center p-4 bg-slate-100 rounded-lg w-full md:w-auto">
                    <div class="text-2xl mb-2">2️⃣</div>
                    <h4 class="font-semibold">使用`odeint_adjoint`求解</h4>
                    <p class="text-sm text-slate-500">前向传播，得到预测轨迹</p>
                </div>
                <div class="flow-arrow hidden md:block"></div>
                <div class="text-center p-4 bg-slate-100 rounded-lg w-full md:w-auto">
                    <div class="text-2xl mb-2">3️⃣</div>
                    <h4 class="font-semibold">计算损失/目标函数</h4>
                    <p class="text-sm text-slate-500">对比预测与真实数据/目标</p>
                </div>
                <div class="flow-arrow hidden md:block"></div>
                <div class="text-center p-4 bg-slate-100 rounded-lg w-full md:w-auto">
                    <div class="text-2xl mb-2">4️⃣</div>
                    <h4 class="font-semibold">调用`loss.backward()`</h4>
                    <p class="text-sm text-slate-500">自动计算所有参数的梯度</p>
                </div>
                 <div class="flow-arrow hidden md:block"></div>
                <div class="text-center p-4 bg-slate-100 rounded-lg w-full md:w-auto">
                    <div class="text-2xl mb-2">5️⃣</div>
                    <h4 class="font-semibold">调用`optimizer.step()`</h4>
                    <p class="text-sm text-slate-500">根据梯度更新参数</p>
                </div>
            </div>
        </section>

        <section id="future" class="text-center">
            <h2 class="text-3xl font-bold mb-8 text-slate-800">前沿展望：迈向智能水处理</h2>
            <div class="grid md:grid-cols-3 gap-8 max-w-5xl mx-auto">
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h3 class="text-xl font-semibold mb-3 text-cyan-700">混合建模</h3>
                    <p class="text-slate-600">将机理模型(ASM)的深刻洞察与机器学习(如神经网络)的强大数据拟合能力相结合，创建能够端到端训练的、更精确、更鲁棒的混合模型。</p>
                </div>
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h3 class="text-xl font-semibold mb-3 text-cyan-700">实时自适应控制</h3>
                    <p class="text-slate-600">结合强化学习等在线学习框架，开发能实时响应进水变化和过程扰动的智能控制系统，实现污水处理厂的“自优化”运行。</p>
                </div>
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h3 class="text-xl font-semibold mb-3 text-cyan-700">数字孪生集成</h3>
                    <p class="text-slate-600">将可微分的ASM模型作为核心，构建更广泛的污水处理厂数字孪生平台，实现对物理实体的精确模拟、预测、优化与控制。</p>
                </div>
            </div>
        </section>

    </main>

<script>
document.addEventListener('DOMContentLoaded', function () {
    const charts = {};

    function createSensitivityChart() {
        const ctx = document.getElementById('sensitivityChart').getContext('2d');
        const data = {
            labels: ['μ_H', 'K_S', 'Y_H', 'b_H', 'K_O,H', 'k_h', 'μ_A', 'K_NH', 'Y_A', 'b_A'],
            datasets: [{
                label: '相对敏感性指数',
                data: [0.85, 0.72, -0.65, 0.55, 0.48, 0.35, 0.28, 0.22, -0.18, 0.11].sort((a,b) => Math.abs(b) - Math.abs(a)),
                backgroundColor: '#06b6d4',
                borderColor: '#0891b2',
                borderWidth: 1
            }]
        };
        charts.sensitivity = new Chart(ctx, {
            type: 'bar',
            data: data,
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: '各参数对出水COD浓度的敏感性排序',
                        font: { size: 16, weight: 'bold' },
                        color: '#334155'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.x !== null) {
                                    label += context.parsed.x.toFixed(2);
                                }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: '归一化敏感性指数 (无量纲)'
                        }
                    },
                    y: {
                        ticks: {
                            autoSkip: false
                        }
                    }
                }
            }
        });
    }

    function createCalibrationChart() {
        const ctx = document.getElementById('calibrationChart').getContext('2d');
        const labels = Array.from({ length: 50 }, (_, i) => i);
        const observedData = labels.map(x => 10 + 5 * Math.sin(x / 5) + (Math.random() - 0.5) * 2);
        
        const initialPrediction = labels.map(x => 15 + 3 * Math.sin(x/6));

        charts.calibration = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: '观测数据',
                        data: observedData,
                        borderColor: '#64748b', // slate-500
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        pointRadius: 0,
                        borderDash: [5, 5]
                    },
                    {
                        label: 'ASM 预测',
                        data: initialPrediction,
                        borderColor: '#06b6d4', // cyan-500
                        backgroundColor: 'rgba(6, 182, 212, 0.1)',
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 200
                },
                plugins: {
                   title: {
                        display: true,
                        text: '模型预测 vs. 观测数据 (出水氨氮)',
                        font: { size: 16, weight: 'bold' },
                        color: '#334155'
                    },
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: '时间 (天)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: '浓度 (mg/L)'
                        }
                    }
                }
            }
        });
        
        const lossDisplay = document.getElementById('lossDisplay');
        const calculateLoss = (pred, obs) => {
            return pred.reduce((sum, p, i) => sum + Math.pow(p - obs[i], 2), 0) / pred.length;
        };
        lossDisplay.textContent = `损失 (Loss): ${calculateLoss(initialPrediction, observedData).toFixed(2)}`;
    }
    
    function createOptimizationChart() {
        const ctx = document.getElementById('optimizationChart').getContext('2d');
        const initialPoint = { x: 80, y: 75 };
        const optimalPoint = { x: 30, y: 25 };

        charts.optimization = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [
                    {
                        label: '运行点',
                        data: [initialPoint],
                        backgroundColor: '#06b6d4',
                        pointRadius: 8,
                        pointHoverRadius: 10
                    },
                    {
                        label: '优化目标区域',
                        data: [{x: 20, y: 20}],
                        backgroundColor: '#10b981',
                        pointRadius: 10,
                        pointStyle: 'star'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: '运行成本 vs. 出水水质优化',
                        font: { size: 16, weight: 'bold' },
                        color: '#334155'
                    },
                    legend: {
                        position: 'bottom'
                    },
                    tooltip: {
                         callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                label += `(成本: ${context.parsed.x.toFixed(0)}, 污染: ${context.parsed.y.toFixed(0)})`;
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: '运行成本指数 (OCI)'
                        },
                        min: 0,
                        max: 100
                    },
                    y: {
                        title: {
                            display: true,
                            text: '出水污染指数 (EQI)'
                        },
                        min: 0,
                        max: 100
                    }
                }
            }
        });
    }

    const tabs = document.querySelectorAll('.tab-button');
    const panes = document.querySelectorAll('.tab-pane');

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const target = tab.getAttribute('data-tab');
            
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            panes.forEach(pane => {
                if (pane.id === `${target}-content`) {
                    pane.classList.remove('hidden');
                } else {
                    pane.classList.add('hidden');
                }
            });

            if (target === 'sensitivity' && !charts.sensitivity) {
                createSensitivityChart();
            } else if (target === 'calibration' && !charts.calibration) {
                createCalibrationChart();
            } else if (target === 'optimization' && !charts.optimization) {
                createOptimizationChart();
            }
        });
    });

    // Initialize the first tab's chart
    createSensitivityChart();

    // --- INTERACTIVITY ---
    const calibrateBtn = document.getElementById('calibrateBtn');
    let calibrationInterval;
    calibrateBtn.addEventListener('click', () => {
        if (calibrationInterval) clearInterval(calibrationInterval);
        
        calibrateBtn.disabled = true;
        calibrateBtn.textContent = '校准中...';

        const chart = charts.calibration;
        const predData = chart.data.datasets[1].data;
        const obsData = chart.data.datasets[0].data;
        const lossDisplay = document.getElementById('lossDisplay');
        let step = 0;
        const totalSteps = 50;

        calibrationInterval = setInterval(() => {
            if (step >= totalSteps) {
                clearInterval(calibrationInterval);
                calibrateBtn.disabled = false;
                calibrateBtn.textContent = '重新校准';
                return;
            }
            
            const progress = step / totalSteps;
            const newPredData = predData.map((p, i) => p + (obsData[i] - p) * (progress * 0.2));
            chart.data.datasets[1].data = newPredData;
            
            const currentLoss = newPredData.reduce((sum, p, i) => sum + Math.pow(p - obsData[i], 2), 0) / newPredData.length;
            lossDisplay.textContent = `损失 (Loss): ${currentLoss.toFixed(2)}`;

            chart.update();
            step++;
        }, 100);
    });
    
    const optimizeBtn = document.getElementById('optimizeBtn');
    let optimizationInterval;
    optimizeBtn.addEventListener('click', () => {
        if (optimizationInterval) clearInterval(optimizationInterval);
        
        optimizeBtn.disabled = true;
        optimizeBtn.textContent = '优化中...';
        
        const chart = charts.optimization;
        const currentPoint = chart.data.datasets[0].data[0];
        const targetPoint = { x: 30, y: 25 };
        const initialPoint = { x: 80, y: 75 };
        
        // Reset if we re-run
        currentPoint.x = initialPoint.x;
        currentPoint.y = initialPoint.y;

        let step = 0;
        const totalSteps = 50;
        
        optimizationInterval = setInterval(() => {
            if (step >= totalSteps) {
                clearInterval(optimizationInterval);
                optimizeBtn.disabled = false;
                optimizeBtn.textContent = '重新优化';
                return;
            }
            
            const progress = step / totalSteps;
            currentPoint.x = initialPoint.x - (initialPoint.x - targetPoint.x) * progress;
            currentPoint.y = initialPoint.y - (initialPoint.y - targetPoint.y) * progress;
            
            chart.update();
            step++;
        }, 80);
    });

});
</script>

</body>
</html>
