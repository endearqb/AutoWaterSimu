## 问题
- 面板中已生成的 `previewPalette`（如分组序列或渐变）未被真正应用，因为当前 `applyForModel(modelKey)` 会取 `modelPalettes[modelKey]` 中按 `scheme/base/steps` 重新计算的调色板，而不是使用用户在面板预览的颜色序列。

## 方案
- 扩展主题存储接口：
  - 将 `setModelPalette(modelKey, scheme, baseColor, steps)` 扩展为支持可选 `paletteOverride?: string[]`，若传入则直接存储该序列，不再用 `computePalette` 重新计算。
  - 保持 `applyForModel(modelKey, tintOrder)` 不变，但它将使用存储的 `palette`（优先 paletteOverride）来应用 CSS 变量。
- 在 `SimulationActionPlate` 的“应用”逻辑中：
  - 生成 `previewPalette` 后，调用 `setModelPalette(modelKey, selectedScheme, selectedBase, previewPalette.length, previewPalette)` 以保存用户选定的系列颜色。
  - 移除或保留 `setPaletteDirect(previewPalette)` 无影响，但主要以 modelPalettes 的存储为准。

## 验证
- 类型检查：`cd frontend; npx tsc --noEmit`。
- 在分组模式下选择 Multi（序列）或 Mono（渐变），观察预览行颜色；点击“应用”后：
  - 节点底色、边框、把手与 MiniMap 颜色按预览行的序列更新；
  - 切换页面后返回，主题按每页面独立存储恢复。

## 交付
- 更新 `themePaletteStore.ts` 方法签名与实现；
- 更新 `SimulationActionPlate.tsx` 的应用逻辑传入 `previewPalette` 覆盖；
- 保持现有互斥逻辑与 UI 不变。